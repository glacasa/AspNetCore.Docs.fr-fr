---
title: Dérivation de sous-clé et chiffrement authentifié dans ASP.NET Core
author: rick-anderson
description: Découvrez les détails de l’implémentation de la dérivation des sous-clés de protection des données ASP.NET Core et du chiffrement authentifié.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: d8038142ccb2597eb1c98738307b8b9a842dae5a
ms.sourcegitcommit: 65add17f74a29a647d812b04517e46cbc78258f9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/19/2020
ms.locfileid: "88630118"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="ba68f-103">Dérivation de sous-clé et chiffrement authentifié dans ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="ba68f-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="ba68f-104">La plupart des clés dans l’anneau de clé contiendront une certaine forme d’entropie et auront des informations algorithmiques indiquant « CBC-mode Encryption + HMAC validation » ou « GCM Encryption + validation ».</span><span class="sxs-lookup"><span data-stu-id="ba68f-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="ba68f-105">Dans ce cas, nous faisons référence à l’entropie incorporée en tant que support de génération de clé principal (ou KM) pour cette clé, et nous effectuons une fonction de dérivation de clé pour dériver les clés qui seront utilisées pour les opérations de chiffrement réelles.</span><span class="sxs-lookup"><span data-stu-id="ba68f-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="ba68f-106">Les clés sont abstraites et une implémentation personnalisée peut ne pas se comporter comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="ba68f-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="ba68f-107">Si la clé fournit sa propre implémentation de `IAuthenticatedEncryptor` plutôt que d’utiliser l’une de nos fabriques intégrées, le mécanisme décrit dans cette section ne s’applique plus.</span><span class="sxs-lookup"><span data-stu-id="ba68f-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="ba68f-108">Données authentifiées supplémentaires et dérivation de sous-clé</span><span class="sxs-lookup"><span data-stu-id="ba68f-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="ba68f-109">L' `IAuthenticatedEncryptor` interface sert d’interface principale pour toutes les opérations de chiffrement authentifiées.</span><span class="sxs-lookup"><span data-stu-id="ba68f-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="ba68f-110">Sa `Encrypt` méthode prend deux mémoires tampons : texte en clair et additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="ba68f-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="ba68f-111">Le contenu en texte en clair n’a pas changé l’appel à `IDataProtector.Protect` , mais AAD est généré par le système et se compose de trois composants :</span><span class="sxs-lookup"><span data-stu-id="ba68f-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="ba68f-112">En-tête magique 32 bits 09 F0 C9 F0 qui identifie cette version du système de protection des données.</span><span class="sxs-lookup"><span data-stu-id="ba68f-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="ba68f-113">ID de la clé 128 bits.</span><span class="sxs-lookup"><span data-stu-id="ba68f-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="ba68f-114">Chaîne de longueur variable formée à partir de la chaîne d’objectif qui a créé le `IDataProtector` qui effectue cette opération.</span><span class="sxs-lookup"><span data-stu-id="ba68f-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="ba68f-115">Étant donné que AAD est unique pour le tuple des trois composants, nous pouvons l’utiliser pour dériver de nouvelles clés de KM au lieu d’utiliser la valeur KM proprement dite dans toutes nos opérations de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="ba68f-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="ba68f-116">Pour chaque appel à `IAuthenticatedEncryptor.Encrypt` , le processus de dérivation de clé suivant a lieu :</span><span class="sxs-lookup"><span data-stu-id="ba68f-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="ba68f-117">Ici, nous appelons le NIST SP800-108 KDF en mode compteur (voir [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) avec les paramètres suivants :</span><span class="sxs-lookup"><span data-stu-id="ba68f-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="ba68f-118">Clé de dérivation de clé (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="ba68f-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="ba68f-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="ba68f-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="ba68f-120">étiquette = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="ba68f-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="ba68f-121">Context = contextHeader | | keymodifier</span><span class="sxs-lookup"><span data-stu-id="ba68f-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="ba68f-122">L’en-tête de contexte est de longueur variable et sert essentiellement d’empreinte numérique des algorithmes pour lesquels nous allons dériver `K_E` et `K_H` .</span><span class="sxs-lookup"><span data-stu-id="ba68f-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="ba68f-123">Le modificateur de clé est une chaîne 128 bits générée de façon aléatoire pour chaque appel à `Encrypt` et sert à garantir une probabilité écrasante que ke et KH sont uniques pour cette opération de chiffrement d’authentification spécifique, même si toutes les autres entrées du KDF sont constantes.</span><span class="sxs-lookup"><span data-stu-id="ba68f-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="ba68f-124">Pour les opérations de chiffrement en mode CBC + validation HMAC, `| K_E |` est la longueur de la clé de chiffrement par bloc symétrique et `| K_H |` est la taille Digest de la routine HMAC.</span><span class="sxs-lookup"><span data-stu-id="ba68f-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="ba68f-125">Pour les opérations de chiffrement GCM + validation, `| K_H | = 0` .</span><span class="sxs-lookup"><span data-stu-id="ba68f-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="ba68f-126">Chiffrement en mode CBC + validation HMAC</span><span class="sxs-lookup"><span data-stu-id="ba68f-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="ba68f-127">Une fois que `K_E` est généré via le mécanisme ci-dessus, nous générons un vecteur d’initialisation aléatoire et exécutons l’algorithme de chiffrement par bloc symétrique pour chiffrer le texte en clair.</span><span class="sxs-lookup"><span data-stu-id="ba68f-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="ba68f-128">Le vecteur d’initialisation et le texte chiffré sont ensuite exécutés via la routine HMAC initialisée avec la clé `K_H` pour produire le Mac.</span><span class="sxs-lookup"><span data-stu-id="ba68f-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="ba68f-129">Ce processus et la valeur de retour sont représentés graphiquement ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="ba68f-129">This process and the return value is represented graphically below.</span></span>

![Processus et retour CBC en mode](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="ba68f-131">L' `IDataProtector.Protect` implémentation [ajoute l’en-tête et l’ID de clé Magic](xref:security/data-protection/implementation/authenticated-encryption-details) à la sortie avant de la renvoyer à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="ba68f-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="ba68f-132">Étant donné que l’en-tête Magic et l’ID de clé font implicitement partie d' [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), et que le modificateur de clé est alimenté comme entrée à KDF, cela signifie que chaque octet de la charge utile finale retournée est authentifié par le Mac.</span><span class="sxs-lookup"><span data-stu-id="ba68f-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="ba68f-133">Chiffrement et validation du mode Galois/Counter</span><span class="sxs-lookup"><span data-stu-id="ba68f-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="ba68f-134">Une fois `K_E` générée via le mécanisme ci-dessus, nous générons une valeur à usage unique 96 bits aléatoire et exécutons l’algorithme de chiffrement par bloc symétrique pour chiffrer le texte en clair et produire la balise d’authentification 128 bits.</span><span class="sxs-lookup"><span data-stu-id="ba68f-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Processus GCM-mode et retour](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="ba68f-136">Bien que GCM prenne en charge nativement le concept d’AAD, nous n’utilisons toujours AAD que dans le KDF d’origine, en choisissant de passer une chaîne vide dans GCM pour son paramètre AAD.</span><span class="sxs-lookup"><span data-stu-id="ba68f-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="ba68f-137">La raison en est le double.</span><span class="sxs-lookup"><span data-stu-id="ba68f-137">The reason for this is two-fold.</span></span> <span data-ttu-id="ba68f-138">Tout d’abord, [pour prendre en charge l’agilité](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) , nous ne souhaitons jamais utiliser `K_M` directement comme clé de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="ba68f-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="ba68f-139">En outre, GCM impose des exigences d’unicité très strictes à ses entrées.</span><span class="sxs-lookup"><span data-stu-id="ba68f-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="ba68f-140">La probabilité que la routine de chiffrement GCM soit appelée sur deux ou plusieurs jeux de données d’entrée distincts avec la même paire (clé, nonce) ne doit pas dépasser 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="ba68f-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="ba68f-141">Si nous corrigeons que nous `K_E` ne pouvons pas effectuer plus de 2 ^ 32 opérations de chiffrement avant d’exécuter le afoul de la limite de 2 ^-32.</span><span class="sxs-lookup"><span data-stu-id="ba68f-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="ba68f-142">Cela peut sembler un très grand nombre d’opérations, mais un serveur Web à trafic élevé peut passer par 4 milliards demandes en quelques jours, et dans la durée de vie normale de ces clés.</span><span class="sxs-lookup"><span data-stu-id="ba68f-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="ba68f-143">Pour rester conforme de la limite de probabilité de 2 ^ 32, nous continuons d’utiliser un modificateur de clé 128 bits et une valeur à usage unique de 96 bits, qui étend radicalement le nombre d’opérations utilisables pour un donné `K_M` .</span><span class="sxs-lookup"><span data-stu-id="ba68f-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="ba68f-144">Pour simplifier la conception, nous partageons le chemin de code KDF entre les opérations CBC et GCM, et dans la mesure où AAD est déjà pris en compte dans le KDF, il n’est pas nécessaire de le transférer à la routine GCM.</span><span class="sxs-lookup"><span data-stu-id="ba68f-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
