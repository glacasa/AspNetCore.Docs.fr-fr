---
title: Scénarios non compatibles avec l’injection de dépendances pour la protection des données dans ASP.NET Core
author: rick-anderson
description: Découvrez comment prendre en charge les scénarios de protection des données dans lesquels vous ne pouvez pas ou ne souhaitez pas utiliser un service fourni par l’injection de dépendances.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/configuration/non-di-scenarios
ms.openlocfilehash: 9ae3d1ec039768b1008702a7a29f4d9a716cb99c
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/26/2020
ms.locfileid: "85404845"
---
# <a name="non-di-aware-scenarios-for-data-protection-in-aspnet-core"></a><span data-ttu-id="8eee8-103">Scénarios non compatibles avec l’injection de dépendances pour la protection des données dans ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="8eee8-103">Non-DI aware scenarios for Data Protection in ASP.NET Core</span></span>

<span data-ttu-id="8eee8-104">Par [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="8eee8-104">By [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="8eee8-105">Le système de protection des données ASP.NET Core est normalement [ajouté à un conteneur de service](xref:security/data-protection/consumer-apis/overview) et consommé par des composants dépendants via l’injection de dépendances (di).</span><span class="sxs-lookup"><span data-stu-id="8eee8-105">The ASP.NET Core Data Protection system is normally [added to a service container](xref:security/data-protection/consumer-apis/overview) and consumed by dependent components via dependency injection (DI).</span></span> <span data-ttu-id="8eee8-106">Toutefois, il existe des cas où cela n’est pas faisable ou souhaité, en particulier lors de l’importation du système dans une application existante.</span><span class="sxs-lookup"><span data-stu-id="8eee8-106">However, there are cases where this isn't feasible or desired, especially when importing the system into an existing app.</span></span>

<span data-ttu-id="8eee8-107">Pour prendre en charge ces scénarios, le package [Microsoft. AspNetCore. dataprotection. extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) fournit un type concret, [DataProtectionProvider](/dotnet/api/Microsoft.AspNetCore.DataProtection.DataProtectionProvider), qui offre un moyen simple d’utiliser la protection des données sans compter sur di.</span><span class="sxs-lookup"><span data-stu-id="8eee8-107">To support these scenarios, the [Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) package provides a concrete type, [DataProtectionProvider](/dotnet/api/Microsoft.AspNetCore.DataProtection.DataProtectionProvider), which offers a simple way to use Data Protection without relying on DI.</span></span> <span data-ttu-id="8eee8-108">Le `DataProtectionProvider` type implémente [IDataProtectionProvider](/dotnet/api/microsoft.aspnetcore.dataprotection.idataprotectionprovider).</span><span class="sxs-lookup"><span data-stu-id="8eee8-108">The `DataProtectionProvider` type implements [IDataProtectionProvider](/dotnet/api/microsoft.aspnetcore.dataprotection.idataprotectionprovider).</span></span> <span data-ttu-id="8eee8-109">La construction `DataProtectionProvider` nécessite uniquement la fourniture d’une instance [DirectoryInfo](/dotnet/api/system.io.directoryinfo) pour indiquer l’emplacement de stockage des clés de chiffrement du fournisseur, comme illustré dans l’exemple de code suivant :</span><span class="sxs-lookup"><span data-stu-id="8eee8-109">Constructing `DataProtectionProvider` only requires providing a [DirectoryInfo](/dotnet/api/system.io.directoryinfo) instance to indicate where the provider's cryptographic keys should be stored, as seen in the following code sample:</span></span>

[!code-csharp[](non-di-scenarios/_static/nodisample1.cs)]

<span data-ttu-id="8eee8-110">Par défaut, le `DataProtectionProvider` type concret ne chiffre pas le matériel de clé brut avant de le rendre persistant dans le système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8eee8-110">By default, the `DataProtectionProvider` concrete type doesn't encrypt raw key material before persisting it to the file system.</span></span> <span data-ttu-id="8eee8-111">Cela permet de prendre en charge les scénarios dans lesquels le développeur pointe vers un partage réseau et le système de protection des données ne peut pas déduire automatiquement un mécanisme de chiffrement à clé inactive approprié.</span><span class="sxs-lookup"><span data-stu-id="8eee8-111">This is to support scenarios where the developer points to a network share and the Data Protection system can't automatically deduce an appropriate at-rest key encryption mechanism.</span></span>

<span data-ttu-id="8eee8-112">En outre, le `DataProtectionProvider` type concret n' [isole](xref:security/data-protection/configuration/overview#per-application-isolation) pas les applications par défaut.</span><span class="sxs-lookup"><span data-stu-id="8eee8-112">Additionally, the `DataProtectionProvider` concrete type doesn't [isolate apps](xref:security/data-protection/configuration/overview#per-application-isolation) by default.</span></span> <span data-ttu-id="8eee8-113">Toutes les applications qui utilisent le même répertoire de clé peuvent partager des charges utiles tant que leurs [paramètres d’objectif](xref:security/data-protection/consumer-apis/purpose-strings) correspondent.</span><span class="sxs-lookup"><span data-stu-id="8eee8-113">All apps using the same key directory can share payloads as long as their [purpose parameters](xref:security/data-protection/consumer-apis/purpose-strings) match.</span></span>

<span data-ttu-id="8eee8-114">Le constructeur [DataProtectionProvider](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionprovider) accepte un rappel de configuration facultatif qui peut être utilisé pour ajuster les comportements du système.</span><span class="sxs-lookup"><span data-stu-id="8eee8-114">The [DataProtectionProvider](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionprovider) constructor accepts an optional configuration callback that can be used to adjust the behaviors of the system.</span></span> <span data-ttu-id="8eee8-115">L’exemple ci-dessous illustre la restauration de l’isolation avec un appel explicite à [SetApplicationName](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionbuilderextensions.setapplicationname).</span><span class="sxs-lookup"><span data-stu-id="8eee8-115">The sample below demonstrates restoring isolation with an explicit call to [SetApplicationName](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionbuilderextensions.setapplicationname).</span></span> <span data-ttu-id="8eee8-116">L’exemple illustre également la configuration du système pour chiffrer automatiquement les clés persistantes à l’aide de Windows DPAPI.</span><span class="sxs-lookup"><span data-stu-id="8eee8-116">The sample also demonstrates configuring the system to automatically encrypt persisted keys using Windows DPAPI.</span></span> <span data-ttu-id="8eee8-117">Si le répertoire pointe vers un partage UNC, vous souhaiterez peut-être distribuer un certificat partagé sur tous les ordinateurs concernés et configurer le système pour qu’il utilise le chiffrement basé sur les certificats avec un appel à [ProtectKeysWithCertificate](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionbuilderextensions.protectkeyswithcertificate).</span><span class="sxs-lookup"><span data-stu-id="8eee8-117">If the directory points to a UNC share, you may wish to distribute a shared certificate across all relevant machines and to configure the system to use certificate-based encryption with a call to [ProtectKeysWithCertificate](/dotnet/api/microsoft.aspnetcore.dataprotection.dataprotectionbuilderextensions.protectkeyswithcertificate).</span></span>

[!code-csharp[](non-di-scenarios/_static/nodisample2.cs)]

> [!TIP]
> <span data-ttu-id="8eee8-118">Les instances du `DataProtectionProvider` type concret sont coûteuses à créer.</span><span class="sxs-lookup"><span data-stu-id="8eee8-118">Instances of the `DataProtectionProvider` concrete type are expensive to create.</span></span> <span data-ttu-id="8eee8-119">Si une application gère plusieurs instances de ce type et si elles utilisent toutes le même répertoire de stockage de clés, les performances de l’application peuvent se dégrader.</span><span class="sxs-lookup"><span data-stu-id="8eee8-119">If an app maintains multiple instances of this type and if they're all using the same key storage directory, app performance might degrade.</span></span> <span data-ttu-id="8eee8-120">Si vous utilisez le `DataProtectionProvider` type, nous vous recommandons de créer ce type une seule fois et de le réutiliser autant que possible.</span><span class="sxs-lookup"><span data-stu-id="8eee8-120">If you use the `DataProtectionProvider` type, we recommend that you create this type once and reuse it as much as possible.</span></span> <span data-ttu-id="8eee8-121">Le `DataProtectionProvider` type et toutes les instances [IDataProtector](/dotnet/api/microsoft.aspnetcore.dataprotection.idataprotector) créées à partir de celui-ci sont thread-safe pour plusieurs appelants.</span><span class="sxs-lookup"><span data-stu-id="8eee8-121">The `DataProtectionProvider` type and all [IDataProtector](/dotnet/api/microsoft.aspnetcore.dataprotection.idataprotector) instances created from it are thread-safe for multiple callers.</span></span>
